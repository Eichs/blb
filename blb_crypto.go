package main

import (
	"fmt"
)

var (
	// === Blb3 自定义 AES 用 ===
	// AES SBox（SubBytes 用，注意是 XOR，不是替换）
	Blb3AESSBox = [256]byte{0x63, 0x7d, 0x75, 0x78, 0xf6, 0x6e, 0x69, 0xc2, 0x38, 0x08, 0x6d, 0x20, 0xf2, 0xda, 0xa5, 0x79, 0xda, 0x93, 0xdb, 0x6e, 0xee, 0x4c, 0x51, 0xe7, 0xb5, 0xcd, 0xb8, 0xb4, 0x80, 0xb9, 0x6c, 0xdf, 0x97, 0xdc, 0xb1, 0x05, 0x12, 0x1a, 0xd1, 0xeb, 0x1c, 0x8c, 0xcf, 0xda, 0x5d, 0xf5, 0x1f, 0x3a, 0x34, 0xf6, 0x11, 0xf0, 0x2c, 0xa3, 0x33, 0xad, 0x3f, 0x2b, 0xba, 0xd9, 0xd7, 0x1a, 0x8c, 0x4a, 0x49, 0xc2, 0x6e, 0x59, 0x5f, 0x2b, 0x1c, 0xe7, 0x1a, 0x72, 0x9c, 0xf8, 0x65, 0xae, 0x61, 0xcb, 0x03, 0x80, 0x52, 0xbe, 0x74, 0xa9, 0xe7, 0x0c, 0x32, 0x92, 0xe4, 0x62, 0x16, 0x11, 0x06, 0x90, 0xb0, 0x8e, 0xc8, 0x98, 0x27, 0x28, 0x55, 0xe2, 0x2d, 0x90, 0x68, 0x14, 0x3c, 0x51, 0xf1, 0xc7, 0x21, 0xd2, 0x32, 0xfc, 0xe6, 0xe8, 0x4e, 0x82, 0xc4, 0xcf, 0xa0, 0x5a, 0x6c, 0x82, 0x8d, 0xad, 0x4d, 0x8d, 0x91, 0x6f, 0xdb, 0x12, 0xc2, 0x90, 0x4c, 0x2e, 0xf4, 0xb6, 0xe8, 0xd0, 0x97, 0xfc, 0xf0, 0x10, 0xdd, 0x4f, 0xb6, 0xbf, 0x06, 0x1f, 0xde, 0x77, 0x22, 0x8f, 0x42, 0xc3, 0x95, 0x44, 0x40, 0x93, 0x98, 0xa9, 0xed, 0xa3, 0x82, 0xfb, 0x6a, 0x7a, 0x06, 0xc9, 0x3d, 0x38, 0x4a, 0xd6, 0x57, 0x79, 0x85, 0xde, 0x39, 0x60, 0xf8, 0x1e, 0xd4, 0xef, 0x4e, 0x51, 0xd9, 0xc7, 0x10, 0xb7, 0x7a, 0xb9, 0xe7, 0xed, 0xd8, 0x63, 0x72, 0x01, 0x20, 0x14, 0xbe, 0xd4, 0x87, 0x70, 0x45, 0x45, 0xa0, 0xef, 0x67, 0xb5, 0x9c, 0xd6, 0x20, 0xd9, 0xb9, 0xec, 0x8d, 0x62, 0x5a, 0x1c, 0xc3, 0x41, 0x01, 0x19, 0x7a, 0xf2, 0x8d, 0x3c, 0x68, 0x73, 0x73, 0xf7, 0x6d, 0x02, 0x22, 0xb8, 0xc6, 0x30, 0x7c, 0x50, 0x7b, 0xfe, 0x4b, 0x13, 0xb4, 0x9f, 0xb9, 0x60, 0xd7, 0xf4, 0x4c, 0xa9, 0x45, 0xe9}
)

// Decrypt 按 C#：
// buffer = buffer[..Math.Min(128, buffer.Length)]
// 1) 首 16 字节 XOR header
// 2) BlbAES.Encrypt(buffer[0:16].ToArray(), header) 覆盖回 buffer[0:16]
// 3) len>16 -> RC4(buffer)（只改 0x10 之后）
// 4) Descramble(buffer[0:16])
func Decrypt(header []byte, buffer []byte) {
	if len(header) != 0x10 {
		panic(fmt.Sprintf("invalid header size: %d != 16", len(header)))
	}
	if len(buffer) == 0 {
		return
	}

	n := len(buffer)
	if n > 128 {
		n = 128
	}
	buf := buffer[:n]

	// Initial XOR step (only first 16 bytes used)
	for i := 0; i < 16 && i < len(buf); i++ {
		buf[i] ^= header[i]
	}

	// Modified AES implementation: calling Encrypt() is intentional.
	// C# does: BlbAES.Encrypt(buffer.Slice(0,16).ToArray(), header).CopyTo(buffer);
	if len(buf) >= 16 {
		in := make([]byte, 16)
		copy(in, buf[:16])
		out := BlbAESEncrypt(in, header) // returns 16 bytes
		copy(buf[:16], out)
	}

	// RC4 only modifies bytes after first 16, but uses early bytes to seed
	if len(buf) > 16 {

		RC4Decrypt(buf)
	}

	// Descramble first 16 bytes
	if len(buf) >= 16 {
		Descramble(buf[:16])
	} else {
		Descramble(buf)
	}
}
func Encrypt(header []byte, buffer []byte) {
	if len(header) != 0x10 {
		panic(fmt.Sprintf("invalid header size: %d != 16", len(header)))
	}
	if len(buffer) == 0 {
		return
	}

	n := len(buffer)
	if n > 128 {
		n = 128
	}
	buf := buffer[:n]

	if len(buf) >= 16 {
		Scramble(buf[:16]) // 用你确认过的“只对16字节”
	} else {
		panic(fmt.Sprintf("buffer too short for Encrypt: %d (<16)", len(buf)))
	}

	if len(buf) > 16 {
		RC4Encrypt(buf)
	}

	if len(buf) >= 16 {
		in := make([]byte, 16)
		copy(in, buf[:16])
		out := BlbAESDecrypt(in, header)
		copy(buf[:16], out)
	}

	for i := 0; i < 16 && i < len(buf); i++ {
		buf[i] ^= header[i]
	}
}

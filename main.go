package main

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"

	"github.com/pierrec/lz4/v4"
)

// === 对应 C# CryptoHelper 中的 Blb3 常量 ===

var (
	// RC4 初始 SBox（256 bytes）
	Blb3RC4Key = [256]byte{0x29, 0x23, 0xbe, 0x84, 0xe1, 0x6c, 0xd6, 0xae, 0x52, 0x90, 0x49, 0xf1, 0xf1, 0xbb, 0xe9, 0xeb, 0xb3, 0xa6, 0xdb, 0x3c, 0x87, 0x0c, 0x3e, 0x99, 0x24, 0x5e, 0x0d, 0x1c, 0x06, 0xb7, 0x47, 0xde, 0xb3, 0x12, 0x4d, 0xc8, 0x43, 0xbb, 0x8b, 0xa6, 0x1f, 0x03, 0x5a, 0x7d, 0x09, 0x38, 0x25, 0x1f, 0x5d, 0xd4, 0xcb, 0xfc, 0x96, 0xf5, 0x45, 0x3b, 0x13, 0x0d, 0x89, 0x0a, 0x1c, 0xdb, 0xae, 0x32, 0x20, 0x9a, 0x50, 0xee, 0x40, 0x78, 0x36, 0xfd, 0x12, 0x49, 0x32, 0xf6, 0x9e, 0x7d, 0x49, 0xdc, 0xad, 0x4f, 0x14, 0xf2, 0x44, 0x40, 0x66, 0xd0, 0x6b, 0xc4, 0x30, 0xb7, 0x32, 0x3b, 0xa1, 0x22, 0xf6, 0x22, 0x91, 0x9d, 0xe1, 0x8b, 0x1f, 0xda, 0xb0, 0xca, 0x99, 0x02, 0xb9, 0x72, 0x9d, 0x49, 0x2c, 0x80, 0x7e, 0xc5, 0x99, 0xd5, 0xe9, 0x80, 0xb2, 0xea, 0xc9, 0xcc, 0x53, 0xbf, 0x67, 0xd6, 0xbf, 0x14, 0xd6, 0x7e, 0x2d, 0xdc, 0x8e, 0x66, 0x83, 0xef, 0x57, 0x49, 0x61, 0xff, 0x69, 0x8f, 0x61, 0xcd, 0xd1, 0x1e, 0x9d, 0x9c, 0x16, 0x72, 0x72, 0xe6, 0x1d, 0xf0, 0x84, 0x4f, 0x4a, 0x77, 0x02, 0xd7, 0xe8, 0x39, 0x2c, 0x53, 0xcb, 0xc9, 0x12, 0x1e, 0x33, 0x74, 0x9e, 0x0c, 0xf4, 0xd5, 0xd4, 0x9f, 0xd4, 0xa4, 0x59, 0x7e, 0x35, 0xcf, 0x32, 0x22, 0xf4, 0xcc, 0xcf, 0xd3, 0x90, 0x2d, 0x48, 0xd3, 0x8f, 0x75, 0xe6, 0xd9, 0x1d, 0x2a, 0xe5, 0xc0, 0xf7, 0x2b, 0x78, 0x81, 0x87, 0x44, 0x0e, 0x5f, 0x50, 0x00, 0xd4, 0x61, 0x8d, 0xbe, 0x7b, 0x05, 0x15, 0x07, 0x3b, 0x33, 0x82, 0x1f, 0x18, 0x70, 0x92, 0xda, 0x64, 0x54, 0xce, 0xb1, 0x85, 0x3e, 0x69, 0x15, 0xf8, 0x46, 0x6a, 0x04, 0x96, 0x73, 0x0e, 0xd9, 0x16, 0x2f, 0x67, 0x68, 0xd4, 0xf7, 0x4a, 0x4a, 0xd0, 0x57, 0x68, 0x76}
	Blb3SBox   = [1024]byte{0xD0, 0x20, 0x41, 0x4A, 0xA2, 0x7A, 0xCE, 0x66, 0x21, 0x7C, 0x8E, 0x45, 0xF4, 0x87, 0x31, 0xDD, 0xD8, 0x35, 0xC2, 0x09, 0xEA, 0x60, 0x38, 0xD2, 0xB4, 0xBE, 0x10, 0x76, 0x7F, 0xB7, 0x0F, 0xFD, 0xCB, 0x02, 0x0E, 0x5B, 0x2E, 0x9B, 0xB1, 0xE1, 0xF5, 0x5E, 0x40, 0x4D, 0x88, 0x98, 0x6F, 0x37, 0xAB, 0xEE, 0x53, 0x79, 0x70, 0x24, 0x6C, 0x67, 0xE6, 0x3C, 0x49, 0x06, 0x59, 0xBA, 0xCF, 0x08, 0x8A, 0xAC, 0xA0, 0x8B, 0x3D, 0xBF, 0x13, 0x73, 0x43, 0x91, 0x00, 0x2B, 0xA1, 0x22, 0x93, 0x3A, 0xCC, 0x4C, 0x44, 0x14, 0x28, 0xF7, 0xED, 0x36, 0x4F, 0xE4, 0xFC, 0x90, 0x0A, 0x9E, 0xD6, 0x77, 0x05, 0xBD, 0x57, 0x3F, 0x96, 0x5F, 0x4B, 0xBC, 0x8D, 0x3E, 0x72, 0xFE, 0x4E, 0xA7, 0xC3, 0xA9, 0x3B, 0x07, 0x89, 0x2F, 0xB8, 0xFF, 0x1D, 0xB6, 0x65, 0x6D, 0xC4, 0x61, 0x39, 0x6A, 0xA3, 0x64, 0xC1, 0xAE, 0xB2, 0x97, 0x29, 0x9F, 0xF2, 0x32, 0x34, 0x1A, 0x58, 0x27, 0x51, 0x71, 0x15, 0x03, 0xEC, 0x47, 0x1E, 0x5C, 0xB3, 0x18, 0x7D, 0xE9, 0x48, 0x6E, 0x55, 0x19, 0x2A, 0xDA, 0x25, 0x80, 0x11, 0xF1, 0x95, 0xE5, 0xE2, 0x83, 0xA5, 0x82, 0x1C, 0x5A, 0xCD, 0xD4, 0x74, 0x9D, 0x33, 0xB5, 0xD5, 0xCA, 0x16, 0xE3, 0x23, 0x84, 0x2C, 0xDE, 0x1B, 0x94, 0xE8, 0x52, 0x01, 0x12, 0x7B, 0x63, 0x50, 0x9A, 0x68, 0xF6, 0xD7, 0x8C, 0x62, 0xE0, 0x17, 0xDB, 0x8F, 0x0C, 0xC0, 0x0D, 0x46, 0xDF, 0xF8, 0x04, 0xEB, 0x75, 0xA6, 0xD1, 0xA4, 0xFB, 0x5D, 0xC8, 0x1F, 0xF3, 0xDC, 0xB0, 0x78, 0xAA, 0x2D, 0xC9, 0x56, 0x9C, 0x86, 0xF9, 0xC6, 0xE7, 0x81, 0x92, 0xA8, 0xEF, 0x54, 0x6B, 0x7E, 0x99, 0xC5, 0xD9, 0xC7, 0xFA, 0xD3, 0x26, 0x30, 0xB9, 0xF0, 0x0B, 0x42, 0xAD, 0x85, 0x69, 0xBB, 0xAF, 0x0B, 0xE2, 0xC2, 0x29, 0xFF, 0xDD, 0xE6, 0x2A, 0xD9, 0x97, 0x30, 0x5E, 0x73, 0x95, 0x48, 0x05, 0x56, 0x26, 0x0F, 0xD2, 0xA2, 0x9A, 0x3C, 0xAE, 0x14, 0xBD, 0xF9, 0x92, 0x23, 0x61, 0x74, 0x31, 0xE1, 0xC3, 0x7A, 0xE5, 0xF0, 0x8A, 0x32, 0xAA, 0x91, 0x1B, 0x79, 0xE7, 0x54, 0x0C, 0x81, 0xD0, 0xD5, 0x08, 0x0E, 0x98, 0x9F, 0x6C, 0xBF, 0xAC, 0x59, 0xED, 0x18, 0x87, 0xDC, 0x85, 0x69, 0xF6, 0x82, 0x01, 0xA7, 0x83, 0x20, 0xD7, 0x10, 0xB9, 0x21, 0x1E, 0x42, 0xD8, 0xB1, 0x4A, 0xA1, 0x66, 0x9D, 0x0D, 0x71, 0x5B, 0x1A, 0xB7, 0x2D, 0xA4, 0x07, 0x65, 0x33, 0x06, 0xF5, 0x67, 0xCF, 0xA8, 0x12, 0xDE, 0x5F, 0x3F, 0x35, 0x13, 0x6F, 0x02, 0x6B, 0xD1, 0xA6, 0x1D, 0xC7, 0x5A, 0x40, 0xB3, 0xF8, 0x90, 0xA5, 0x9B, 0x94, 0xA0, 0x00, 0x60, 0x68, 0x50, 0xDA, 0x43, 0x38, 0x7B, 0x37, 0x4F, 0xF4, 0x58, 0xC5, 0x64, 0x22, 0x3D, 0xC9, 0xFC, 0x0A, 0x3A, 0xBA, 0x78, 0x6A, 0xFA, 0x5C, 0x8C, 0xE0, 0x77, 0x88, 0x41, 0xCD, 0x51, 0x9E, 0xA3, 0x4C, 0x1F, 0xCA, 0x16, 0x6E, 0x28, 0xF1, 0xFE, 0x8E, 0x99, 0xC8, 0xFB, 0x19, 0x7E, 0x7F, 0x45, 0x4D, 0xE4, 0xDF, 0x75, 0x57, 0x6D, 0x2F, 0xBB, 0x46, 0xE3, 0xEA, 0xDB, 0x53, 0x34, 0x36, 0x80, 0xEF, 0xF7, 0x7C, 0x1C, 0xB0, 0x9C, 0x47, 0x62, 0xB2, 0xB5, 0x89, 0x17, 0x09, 0xCE, 0xC6, 0xC1, 0x44, 0xCB, 0x63, 0x8B, 0xD6, 0x84, 0xB4, 0xEE, 0xF3, 0x55, 0x8F, 0xD4, 0x49, 0x3E, 0x2B, 0x96, 0xE8, 0xFD, 0x04, 0x8D, 0x52, 0xBC, 0x93, 0x70, 0xAB, 0xE9, 0x4E, 0xEB, 0x2E, 0x76, 0xA9, 0x86, 0xCC, 0xD3, 0xC4, 0xAF, 0x39, 0x2C, 0xF2, 0x4B, 0xAD, 0x72, 0x5D, 0xBE, 0xEC, 0x27, 0xC0, 0x15, 0x03, 0x24, 0xB6, 0x7D, 0x3B, 0x11, 0xB8, 0x25, 0xDD, 0x2F, 0xFB, 0x06, 0xB1, 0x5B, 0xF2, 0xA5, 0x8C, 0xC9, 0xCA, 0xC7, 0x15, 0xB3, 0xFC, 0x7C, 0xEB, 0xDC, 0x50, 0x91, 0x83, 0x80, 0x82, 0x53, 0xD3, 0xE4, 0xD9, 0x73, 0x64, 0x27, 0xC2, 0xA0, 0x67, 0xEE, 0x54, 0x0D, 0xAA, 0x77, 0x97, 0x85, 0xC5, 0x75, 0x23, 0xA7, 0x37, 0x01, 0x19, 0xD1, 0x79, 0xF8, 0x51, 0xA9, 0x49, 0x3A, 0xE9, 0xF7, 0xF0, 0x5C, 0xD4, 0x74, 0x1A, 0xB9, 0x1D, 0x94, 0x28, 0x13, 0xF4, 0x0A, 0x90, 0x6C, 0xFA, 0x95, 0x70, 0x3B, 0x9F, 0xE3, 0xE2, 0x4E, 0x04, 0xBC, 0xA3, 0x21, 0xD2, 0x5E, 0xDB, 0x30, 0x44, 0x2C, 0x76, 0xE1, 0x3C, 0x69, 0x1C, 0xC0, 0x4F, 0x4B, 0x0B, 0x9A, 0xFD, 0x6F, 0xD8, 0x66, 0xB7, 0x7E, 0x17, 0x25, 0xC3, 0xC8, 0xF3, 0xDE, 0x96, 0x3E, 0x62, 0xFF, 0xDF, 0x4C, 0x2D, 0x10, 0xE8, 0x46, 0xF6, 0xCD, 0x24, 0xE6, 0xC1, 0x61, 0x8F, 0x4A, 0x8B, 0x5F, 0x7A, 0xEA, 0x65, 0x86, 0x31, 0x20, 0xD5, 0x71, 0xF1, 0x48, 0xBE, 0x40, 0x0E, 0x39, 0x43, 0x07, 0x9B, 0x68, 0xCC, 0x3F, 0x60, 0x2A, 0xBD, 0x36, 0xB5, 0x56, 0x42, 0xCE, 0x72, 0x41, 0x45, 0x7F, 0x7B, 0x9E, 0x03, 0x09, 0x98, 0x9D, 0x00, 0xD6, 0x99, 0x1B, 0xB0, 0x5D, 0x6D, 0x63, 0xC6, 0xC4, 0x1E, 0x84, 0xB6, 0x0F, 0x11, 0xAC, 0xE5, 0xAF, 0xB8, 0xBF, 0x3D, 0xAE, 0x55, 0xA4, 0xB4, 0x18, 0x32, 0x1F, 0xF9, 0x93, 0x81, 0x2E, 0xEF, 0x05, 0x22, 0x14, 0x26, 0x87, 0xED, 0xFE, 0x8D, 0xEC, 0xB2, 0xCF, 0x35, 0xCB, 0xE7, 0x6E, 0x5A, 0x7D, 0x29, 0x08, 0x12, 0x52, 0xA1, 0x59, 0x58, 0x9C, 0xD0, 0x2B, 0xA2, 0xBB, 0x4D, 0xA6, 0x88, 0xAB, 0x6A, 0x33, 0xA8, 0x8A, 0x02, 0xAD, 0x8E, 0x16, 0x89, 0xD7, 0x34, 0xE0, 0xBA, 0xF5, 0x38, 0xDA, 0x92, 0x78, 0x6B, 0x47, 0x57, 0x0C, 0x75, 0xBD, 0x5C, 0xFB, 0xC1, 0xAB, 0x47, 0x48, 0x72, 0x0F, 0x46, 0x10, 0x3C, 0xEA, 0xCD, 0x2E, 0xC0, 0x92, 0x02, 0x1D, 0x6F, 0xA0, 0xCC, 0xAC, 0x50, 0x52, 0xD5, 0x0B, 0xDD, 0x06, 0x21, 0xD0, 0x3B, 0xBB, 0xC3, 0xB5, 0xE5, 0x89, 0xB8, 0x1B, 0x1A, 0xDC, 0x3F, 0x6E, 0xDE, 0x9F, 0x39, 0x68, 0xB2, 0x7C, 0x24, 0xA8, 0x64, 0xFE, 0x4F, 0xCE, 0xCF, 0xF1, 0x5D, 0x28, 0xF6, 0xF3, 0xFD, 0x29, 0xB6, 0xA7, 0x8C, 0xA5, 0x49, 0xEB, 0x9C, 0xEE, 0x1C, 0xC4, 0xBA, 0xD7, 0x6A, 0x65, 0x43, 0x6D, 0xC6, 0x8F, 0x7A, 0xD8, 0x7F, 0x96, 0x63, 0x36, 0xF2, 0xDF, 0x62, 0xB0, 0xAA, 0xE1, 0x69, 0x7B, 0x6C, 0x45, 0x3D, 0xB4, 0x51, 0x22, 0x7D, 0x58, 0xD9, 0x60, 0x56, 0xC2, 0x5F, 0x41, 0x01, 0xFF, 0x54, 0x07, 0xA6, 0xED, 0x20, 0x34, 0x26, 0xC8, 0x94, 0x13, 0x4C, 0xD4, 0x12, 0x25, 0x9E, 0x80, 0xB7, 0x66, 0x31, 0x30, 0x0C, 0x40, 0x08, 0xC9, 0xE6, 0xF4, 0x8E, 0xC5, 0x82, 0x71, 0x76, 0x7E, 0x55, 0xEF, 0xE9, 0xEC, 0x19, 0x98, 0x09, 0xD6, 0xB1, 0xDA, 0x5E, 0xBC, 0xD2, 0x03, 0x74, 0x86, 0x0A, 0x5B, 0x17, 0x53, 0x79, 0x2C, 0xDB, 0x0E, 0x78, 0x04, 0x5A, 0xF9, 0x9D, 0x85, 0x8B, 0x83, 0xD1, 0x4D, 0xA2, 0x27, 0xB3, 0x14, 0x84, 0xAD, 0x61, 0xAE, 0x15, 0x90, 0x95, 0x1E, 0xAF, 0x6B, 0x23, 0xE4, 0x16, 0x91, 0x2F, 0x99, 0xFA, 0x00, 0x1F, 0x33, 0xCA, 0xE2, 0x97, 0x2A, 0x67, 0xA9, 0x0D, 0xE7, 0x2B, 0x4A, 0x44, 0x87, 0x2D, 0x42, 0x9B, 0x32, 0x8A, 0x3E, 0xF5, 0xD3, 0x8D, 0x93, 0x18, 0x81, 0x37, 0x88, 0xFC, 0x70, 0xF7, 0xC7, 0xA1, 0x38, 0xCB, 0x4E, 0xA4, 0xA3, 0x57, 0x11, 0xB9, 0x35, 0x73, 0xE8, 0xE0, 0xE3, 0x59, 0x3A, 0x77, 0xBE, 0xF0, 0x05, 0x4B, 0xBF, 0x9A, 0xF8}
	// Descramble 用 ShiftRow
	// C#：BlbShiftRow[(2-i)*0x10 + j]，i∈[0,2], j∈[0,15]
	Blb3ShiftRow = [48]byte{0x05, 0x0A, 0x03, 0x08, 0x0F, 0x02, 0x07, 0x09, 0x00, 0x06, 0x0E, 0x0B, 0x0C, 0x01, 0x04, 0x0D, 0x05, 0x0E, 0x08, 0x06, 0x01, 0x0C, 0x07, 0x09, 0x00, 0x0F, 0x03, 0x0B, 0x04, 0x0D, 0x02, 0x0A, 0x04, 0x0F, 0x0D, 0x05, 0x0C, 0x08, 0x02, 0x09, 0x0B, 0x01, 0x07, 0x03, 0x0A, 0x00, 0x06, 0x0E}
	// Descramble 用 Key（j % 8）
	Blb3Key = [8]byte{0xA9, 0x85, 0x57, 0x4D, 0x8B, 0xF9, 0x81, 0x33}
	// Descramble 用 Mul（j % 8）
	Blb3Mul = [8]byte{0xC8, 0x73, 0xBF, 0x25, 0xD9, 0x9C, 0x7E, 0x6C}
	// === GF(256) 运算表 ===
	// 用于 GF256Mul
	GF256Log = [256]byte{0x00, 0x00, 0x19, 0x01, 0x32, 0x02, 0x1A, 0xC6, 0x4B, 0xC7, 0x1B, 0x68, 0x33, 0xEE, 0xDF, 0x03, 0x64, 0x04, 0xE0, 0x0E, 0x34, 0x8D, 0x81, 0xEF, 0x4C, 0x71, 0x08, 0xC8, 0xF8, 0x69, 0x1C, 0xC1, 0x7D, 0xC2, 0x1D, 0xB5, 0xF9, 0xB9, 0x27, 0x6A, 0x4D, 0xE4, 0xA6, 0x72, 0x9A, 0xC9, 0x09, 0x78, 0x65, 0x2F, 0x8A, 0x05, 0x21, 0x0F, 0xE1, 0x24, 0x12, 0xF0, 0x82, 0x45, 0x35, 0x93, 0xDA, 0x8E, 0x96, 0x8F, 0xDB, 0xBD, 0x36, 0xD0, 0xCE, 0x94, 0x13, 0x5C, 0xD2, 0xF1, 0x40, 0x46, 0x83, 0x38, 0x66, 0xDD, 0xFD, 0x30, 0xBF, 0x06, 0x8B, 0x62, 0xB3, 0x25, 0xE2, 0x98, 0x22, 0x88, 0x91, 0x10, 0x7E, 0x6E, 0x48, 0xC3, 0xA3, 0xB6, 0x1E, 0x42, 0x3A, 0x6B, 0x28, 0x54, 0xFA, 0x85, 0x3D, 0xBA, 0x2B, 0x79, 0x0A, 0x15, 0x9B, 0x9F, 0x5E, 0xCA, 0x4E, 0xD4, 0xAC, 0xE5, 0xF3, 0x73, 0xA7, 0x57, 0xAF, 0x58, 0xA8, 0x50, 0xF4, 0xEA, 0xD6, 0x74, 0x4F, 0xAE, 0xE9, 0xD5, 0xE7, 0xE6, 0xAD, 0xE8, 0x2C, 0xD7, 0x75, 0x7A, 0xEB, 0x16, 0x0B, 0xF5, 0x59, 0xCB, 0x5F, 0xB0, 0x9C, 0xA9, 0x51, 0xA0, 0x7F, 0x0C, 0xF6, 0x6F, 0x17, 0xC4, 0x49, 0xEC, 0xD8, 0x43, 0x1F, 0x2D, 0xA4, 0x76, 0x7B, 0xB7, 0xCC, 0xBB, 0x3E, 0x5A, 0xFB, 0x60, 0xB1, 0x86, 0x3B, 0x52, 0xA1, 0x6C, 0xAA, 0x55, 0x29, 0x9D, 0x97, 0xB2, 0x87, 0x90, 0x61, 0xBE, 0xDC, 0xFC, 0xBC, 0x95, 0xCF, 0xCD, 0x37, 0x3F, 0x5B, 0xD1, 0x53, 0x39, 0x84, 0x3C, 0x41, 0xA2, 0x6D, 0x47, 0x14, 0x2A, 0x9E, 0x5D, 0x56, 0xF2, 0xD3, 0xAB, 0x44, 0x11, 0x92, 0xD9, 0x23, 0x20, 0x2E, 0x89, 0xB4, 0x7C, 0xB8, 0x26, 0x77, 0x99, 0xE3, 0xA5, 0x67, 0x4A, 0xED, 0xDE, 0xC5, 0x31, 0xFE, 0x18, 0x0D, 0x63, 0x8C, 0x80, 0xC0, 0xF7, 0x70, 0x07}
	GF256Exp = [256]byte{0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35, 0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA, 0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31, 0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD, 0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88, 0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A, 0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3, 0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0, 0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41, 0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75, 0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80, 0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54, 0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA, 0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E, 0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17, 0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01}
	// === Blb3 自定义 AES 用 ===
	// AES SBox（SubBytes 用，注意是 XOR，不是替换）
	Blb3AESSBox = [256]byte{0x63, 0x7d, 0x75, 0x78, 0xf6, 0x6e, 0x69, 0xc2, 0x38, 0x08, 0x6d, 0x20, 0xf2, 0xda, 0xa5, 0x79, 0xda, 0x93, 0xdb, 0x6e, 0xee, 0x4c, 0x51, 0xe7, 0xb5, 0xcd, 0xb8, 0xb4, 0x80, 0xb9, 0x6c, 0xdf, 0x97, 0xdc, 0xb1, 0x05, 0x12, 0x1a, 0xd1, 0xeb, 0x1c, 0x8c, 0xcf, 0xda, 0x5d, 0xf5, 0x1f, 0x3a, 0x34, 0xf6, 0x11, 0xf0, 0x2c, 0xa3, 0x33, 0xad, 0x3f, 0x2b, 0xba, 0xd9, 0xd7, 0x1a, 0x8c, 0x4a, 0x49, 0xc2, 0x6e, 0x59, 0x5f, 0x2b, 0x1c, 0xe7, 0x1a, 0x72, 0x9c, 0xf8, 0x65, 0xae, 0x61, 0xcb, 0x03, 0x80, 0x52, 0xbe, 0x74, 0xa9, 0xe7, 0x0c, 0x32, 0x92, 0xe4, 0x62, 0x16, 0x11, 0x06, 0x90, 0xb0, 0x8e, 0xc8, 0x98, 0x27, 0x28, 0x55, 0xe2, 0x2d, 0x90, 0x68, 0x14, 0x3c, 0x51, 0xf1, 0xc7, 0x21, 0xd2, 0x32, 0xfc, 0xe6, 0xe8, 0x4e, 0x82, 0xc4, 0xcf, 0xa0, 0x5a, 0x6c, 0x82, 0x8d, 0xad, 0x4d, 0x8d, 0x91, 0x6f, 0xdb, 0x12, 0xc2, 0x90, 0x4c, 0x2e, 0xf4, 0xb6, 0xe8, 0xd0, 0x97, 0xfc, 0xf0, 0x10, 0xdd, 0x4f, 0xb6, 0xbf, 0x06, 0x1f, 0xde, 0x77, 0x22, 0x8f, 0x42, 0xc3, 0x95, 0x44, 0x40, 0x93, 0x98, 0xa9, 0xed, 0xa3, 0x82, 0xfb, 0x6a, 0x7a, 0x06, 0xc9, 0x3d, 0x38, 0x4a, 0xd6, 0x57, 0x79, 0x85, 0xde, 0x39, 0x60, 0xf8, 0x1e, 0xd4, 0xef, 0x4e, 0x51, 0xd9, 0xc7, 0x10, 0xb7, 0x7a, 0xb9, 0xe7, 0xed, 0xd8, 0x63, 0x72, 0x01, 0x20, 0x14, 0xbe, 0xd4, 0x87, 0x70, 0x45, 0x45, 0xa0, 0xef, 0x67, 0xb5, 0x9c, 0xd6, 0x20, 0xd9, 0xb9, 0xec, 0x8d, 0x62, 0x5a, 0x1c, 0xc3, 0x41, 0x01, 0x19, 0x7a, 0xf2, 0x8d, 0x3c, 0x68, 0x73, 0x73, 0xf7, 0x6d, 0x02, 0x22, 0xb8, 0xc6, 0x30, 0x7c, 0x50, 0x7b, 0xfe, 0x4b, 0x13, 0xb4, 0x9f, 0xb9, 0x60, 0xd7, 0xf4, 0x4c, 0xa9, 0x45, 0xe9}

	// AES 初始 Shift（Expand() 第一轮用）
	Blb3AESShift = [16]byte{0x0, 0x4, 0x8, 0xc, 0x1, 0x5, 0x9, 0xd, 0x2, 0x6, 0xa, 0xe, 0x3, 0x7, 0xb, 0xf}
)

// ============================================================
//   Blb3RC4Key   [256]byte
//   Blb3SBox     [1024]byte
//   Blb3ShiftRow [48]byte
//   Blb3Key      [8]byte
//   Blb3Mul      [8]byte
//   GF256Log     [256]byte
//   GF256Exp     [256]byte
//   Blb3AESSBox  [256]byte
//   Blb3AESShift [16]byte
// ============================================================

// -------------------- BlbUtils (C# BlbUtils) --------------------

// Decrypt 按 C#：
// buffer = buffer[..Math.Min(128, buffer.Length)]
// 1) 首 16 字节 XOR header
// 2) BlbAES.Encrypt(buffer[0:16].ToArray(), header) 覆盖回 buffer[0:16]
// 3) len>16 -> RC4(buffer)（只改 0x10 之后）
// 4) Descramble(buffer[0:16])
func Decrypt(header []byte, buffer []byte) {
	if len(header) != 0x10 {
		panic(fmt.Sprintf("invalid header size: %d != 16", len(header)))
	}
	if len(buffer) == 0 {
		return
	}

	n := len(buffer)
	if n > 128 {
		n = 128
	}
	buf := buffer[:n]

	// Initial XOR step (only first 16 bytes used)
	for i := 0; i < 16 && i < len(buf); i++ {
		buf[i] ^= header[i]
	}

	// Modified AES implementation: calling Encrypt() is intentional.
	// C# does: BlbAES.Encrypt(buffer.Slice(0,16).ToArray(), header).CopyTo(buffer);
	if len(buf) >= 16 {
		in := make([]byte, 16)
		copy(in, buf[:16])
		out := BlbAESEncrypt(in, header) // returns 16 bytes
		copy(buf[:16], out)
	}

	// RC4 only modifies bytes after first 16, but uses early bytes to seed
	if len(buf) > 16 {
		RC4(buf)
	}

	// Descramble first 16 bytes
	if len(buf) >= 16 {
		Descramble(buf[:16])
	} else {
		Descramble(buf)
	}
}

func gf256Mul(a, b byte) byte {
	// C#: (a==0||b==0)?0: GF256Exp[(GF256Log[a]+GF256Log[b])%0xFF]
	if a == 0 || b == 0 {
		return 0
	}
	la := int(GF256Log[a])
	lb := int(GF256Log[b])
	return GF256Exp[(la+lb)%0xFF]
}

// Descramble: 完全照 C#
// for i in 0..2:
//
//	for j in 0..len-1:
//	  k = BlbShiftRow[(2-i)*0x10 + j]
//	  idx=j%8
//	  vector[j] = BlbKey[idx] ^ BlbSBox[(j%4*0x100) | GF256Mul(BlbMul[idx], buf[k%len])]
//	copy vector->buf
func Descramble(buf []byte) {
	if len(buf) == 0 {
		return
	}
	vector := make([]byte, len(buf))

	for i := 0; i < 3; i++ {
		for j := 0; j < len(buf); j++ {
			k := int(Blb3ShiftRow[(2-i)*0x10+j])
			idx := j % 8

			m := gf256Mul(Blb3Mul[idx], buf[k%len(buf)])

			// (j % 4 * 0x100) | m
			sboxIndex := (j%4)*0x100 | int(m)
			vector[j] = Blb3Key[idx] ^ Blb3SBox[sboxIndex]
		}
		copy(buf, vector)
	}
}

// RC4: 完全照 C# 的写法（注意它不是标准 RC4，后面还有 xor/sub/add 三种操作）
//
// C#:
// byte[] S = new byte[256]; BlbRC4Key.CopyTo(S,0);
// byte[] T = new byte[256];
// for (i=0; i<256; i+=2) { T[i]=buf[i&6]; T[i+1]=buf[(i+1)&7]; }
// KSA swap
// PRGA: for iteration < buf.Length-0x10:
//
//	i=(i+1)%256; j=(j+S[i])%256; swap
//	K=S[(S[j]+S[i])%256]
//	switch (buf[(i%8)+8]%3) { xor / -= / += } on buf[iteration+0x10]
func RC4(buf []byte) {
	if len(buf) <= 16 {
		return
	}

	var S [256]byte
	copy(S[:], Blb3RC4Key[:])

	var T [256]byte
	for i := 0; i < 256; i += 2 {
		T[i] = buf[i&6]
		T[i+1] = buf[(i+1)&7]
	}

	// KSA
	j := 0
	for i := 0; i < 256; i++ {
		j = (j + int(S[i]) + int(T[i])) % 256
		S[i], S[j] = S[j], S[i]
	}

	// PRGA-ish + custom operation
	i := 0
	j = 0
	for iteration := 0; iteration < len(buf)-0x10; iteration++ {
		i = (i + 1) % 256
		j = (j + int(S[i])) % 256
		S[i], S[j] = S[j], S[i]

		K := S[(int(S[j])+int(S[i]))%256]

		switch buf[(i%8)+8] % 3 {
		case 0:
			buf[iteration+0x10] ^= K
		case 1:
			buf[iteration+0x10] -= K // uint8 自动 mod 256 回绕
		case 2:
			buf[iteration+0x10] += K
		}
	}
}

// -------------------- BlbAES (C# BlbAES) --------------------

// 常量表：从你 C# 里原样搬过来（不要改动）

type CompressionType byte

const (
	CompressionNone  CompressionType = 0
	CompressionOodle CompressionType = 1
	CompressionLzma  CompressionType = 2
	CompressionLz4   CompressionType = 3
	CompressionLz4HC CompressionType = 4
)

// -------------------- 对应 BundleFile.StorageBlock / Node --------------------

type StorageBlockFlags uint32

type StorageBlock struct {
	CompressedSize   uint32
	UncompressedSize uint32
	Flags            StorageBlockFlags
}

type Node struct {
	Offset int32
	Size   int32
	Flags  uint32
	Path   string
}

type Blb3File struct {
	Offset int64

	Header16 []byte // 16 bytes header used as key material
	Blocks   []StorageBlock
	Nodes    []Node

	// 解出来的 blocks 全部拼起来的“解压后块流”
	BlocksStream []byte
}

// -------------------- 低成本 little-endian 读取器（带 Position/Seek/Align） --------------------

type binReader struct {
	rs    io.ReadSeeker
	order binary.ByteOrder
}

func newBinReader(rs io.ReadSeeker) *binReader {
	return &binReader{rs: rs, order: binary.LittleEndian}
}

func (br *binReader) Pos() int64 {
	p, _ := br.rs.Seek(0, io.SeekCurrent)
	return p
}
func (br *binReader) Seek(pos int64) error {
	_, err := br.rs.Seek(pos, io.SeekStart)
	return err
}
func (br *binReader) Skip(n int64) error {
	_, err := br.rs.Seek(n, io.SeekCurrent)
	return err
}
func (br *binReader) Align(align int64) error {
	if align <= 1 {
		return nil
	}
	p := br.Pos()
	m := p % align
	if m == 0 {
		return nil
	}
	_, err := br.rs.Seek(align-m, io.SeekCurrent)
	return err
}
func (br *binReader) ReadU8() (byte, error) {
	var b [1]byte
	_, err := io.ReadFull(br.rs, b[:])
	return b[0], err
}
func (br *binReader) ReadU32() (uint32, error) {
	var b [4]byte
	_, err := io.ReadFull(br.rs, b[:])
	return br.order.Uint32(b[:]), err
}
func (br *binReader) ReadI32() (int32, error) {
	u, err := br.ReadU32()
	return int32(u), err
}
func (br *binReader) ReadI64() (int64, error) {
	var b [8]byte
	_, err := io.ReadFull(br.rs, b[:])
	return int64(br.order.Uint64(b[:])), err
}
func (br *binReader) ReadBytes(n int) ([]byte, error) {
	buf := make([]byte, n)
	_, err := io.ReadFull(br.rs, buf)
	return buf, err
}

// ReadStringToNull(固定长度) —— C# reader.ReadStringToNull(4)
func (br *binReader) ReadStringToNullFixed(n int) (string, error) {
	b, err := br.ReadBytes(n)
	if err != nil {
		return "", err
	}
	// 截断到 0
	for i := 0; i < len(b); i++ {
		if b[i] == 0 {
			return string(b[:i]), nil
		}
	}
	return string(b), nil
}

// ReadStringToNull(不定长) —— C# reader.ReadStringToNull()
func (br *binReader) ReadStringToNull() (string, error) {
	var out []byte
	var one [1]byte
	for {
		if _, err := io.ReadFull(br.rs, one[:]); err != nil {
			return "", err
		}
		if one[0] == 0 {
			return string(out), nil
		}
		out = append(out, one[0])
	}
}

// -------------------- 入口：ParseBlb3 --------------------

// ParseBlb3：
// 1) 读签名 "Blb\x03"
// 2) 读 size（compressedBlocksInfoSize）
// 3) 跳过 4 bytes（和你 C# reader.ReadUInt32() 一样）
// 4) 读 Header16（16 bytes）
// 5) 读 headerBytes(size)，Decrypt(Header16, headerBytes)
// 6) 解析 blocks/nodes/path
// 7) 读取每个 block：None/LZ4/LZ4HC -> 需要 Decrypt(Header16, blockData) 后写入 blocksStream
func ParseBlb3(rs io.ReadSeeker) (*Blb3File, error) {
	br := newBinReader(rs)
	f := &Blb3File{Offset: br.Pos()}

	sig, err := br.ReadStringToNullFixed(4)
	if err != nil {
		return nil, err
	}
	if sig != "Blb\x03" {
		return nil, fmt.Errorf("not a Blb3 file, sig=%q", sig)
	}

	size, err := br.ReadU32()
	if err != nil {
		return nil, err
	}

	// skip 4 bytes (C# reader.ReadUInt32();)
	if _, err := br.ReadU32(); err != nil {
		return nil, err
	}

	header16, err := br.ReadBytes(16)
	if err != nil {
		return nil, err
	}
	f.Header16 = header16

	headerBytes, err := br.ReadBytes(int(size))
	if err != nil {
		return nil, err
	}

	// 关键：解密 blocksInfo+directory 的 headerBytes
	Decrypt(f.Header16, headerBytes)

	blocks, nodes, err := parseBlocksInfoAndDirectory(headerBytes)
	if err != nil {
		return nil, err
	}
	f.Blocks = blocks
	f.Nodes = nodes

	// 读取 blocks + 解压/解密拼出 BlocksStream
	blocksStream, err := readBlocksAndBuildStream(br, f.Header16, f.Blocks)
	if err != nil {
		return nil, err
	}
	f.BlocksStream = blocksStream

	return f, nil
}

// -------------------- 解析 headerBytes（对应 ReadBlocksInfoAndDirectory） --------------------

func parseBlocksInfoAndDirectory(headerBytes []byte) ([]StorageBlock, []Node, error) {
	br := newBinReader(bytes.NewReader(headerBytes))

	_, err := br.ReadU32() // m_Header.size
	if err != nil {
		return nil, nil, err
	}
	lastUncompressedSizeU32, err := br.ReadU32()
	if err != nil {
		return nil, nil, err
	}

	if err := br.Skip(4); err != nil { // reader.Position += 4
		return nil, nil, err
	}

	if _, err := br.ReadI32(); err != nil { // blobOffset
		return nil, nil, err
	}
	if _, err := br.ReadU32(); err != nil { // blobSize
		return nil, nil, err
	}

	compByte, err := br.ReadU8()
	if err != nil {
		return nil, nil, err
	}
	compressionType := CompressionType(compByte)

	b, err := br.ReadU8()
	if err != nil {
		return nil, nil, err
	}
	uncompressedSize := uint32(1) << b

	if err := br.Align(4); err != nil { // reader.AlignStream()
		return nil, nil, err
	}

	blocksInfoCount, err := br.ReadI32()
	if err != nil {
		return nil, nil, err
	}
	nodesCount, err := br.ReadI32()
	if err != nil {
		return nil, nil, err
	}

	// ✅ 修正：basePos 必须是 “读 Int64 之前”的位置
	base := br.Pos()
	rel, err := br.ReadI64()
	if err != nil {
		return nil, nil, err
	}
	blocksInfoOffset := base + rel

	base = br.Pos()
	rel, err = br.ReadI64()
	if err != nil {
		return nil, nil, err
	}
	nodesInfoOffset := base + rel

	base = br.Pos()
	rel, err = br.ReadI64()
	if err != nil {
		return nil, nil, err
	}
	flagInfoOffset := base + rel

	// blocks
	if err := br.Seek(blocksInfoOffset); err != nil {
		return nil, nil, err
	}
	blocks := make([]StorageBlock, 0, blocksInfoCount)
	for i := int32(0); i < blocksInfoCount; i++ {
		csz, err := br.ReadU32()
		if err != nil {
			return nil, nil, err
		}
		usz := uncompressedSize
		if i == blocksInfoCount-1 {
			usz = lastUncompressedSizeU32
		}
		blocks = append(blocks, StorageBlock{
			CompressedSize:   csz,
			UncompressedSize: usz,
			Flags:            StorageBlockFlags(compressionType),
		})
	}

	for i := len(blocks) - 1; i > 0; i-- {
		blocks[i].CompressedSize -= blocks[i-1].CompressedSize
		if blocks[i].CompressedSize == blocks[i].UncompressedSize {
			blocks[i].Flags = StorageBlockFlags(CompressionNone)
		} else {
			blocks[i].Flags = StorageBlockFlags(compressionType)
		}
	}

	// nodes
	if err := br.Seek(nodesInfoOffset); err != nil {
		return nil, nil, err
	}
	nodes := make([]Node, 0, nodesCount)

	for i := int32(0); i < nodesCount; i++ {
		off, err := br.ReadI32()
		if err != nil {
			return nil, nil, err
		}
		sz, err := br.ReadI32()
		if err != nil {
			return nil, nil, err
		}

		// flag
		pos := br.Pos()
		if err := br.Seek(flagInfoOffset); err != nil {
			return nil, nil, err
		}
		flag0, err := br.ReadU32()
		if err != nil {
			return nil, nil, err
		}
		flag := flag0
		if i >= 0x20 {
			flag1, err := br.ReadU32()
			if err != nil {
				return nil, nil, err
			}
			flag = flag1
		}
		nodeFlags := uint32(flag&(1<<uint32(i))) * 4

		if err := br.Seek(pos); err != nil {
			return nil, nil, err
		}

		// ✅ 修正：pathOffset = (posBeforeReadI64) + rel
		base = br.Pos()
		rel, err = br.ReadI64()
		if err != nil {
			return nil, nil, err
		}
		pathOffset := base + rel

		pos2 := br.Pos()
		if err := br.Seek(pathOffset); err != nil {
			return nil, nil, err
		}
		p, err := br.ReadStringToNull()
		if err != nil {
			return nil, nil, err
		}
		if err := br.Seek(pos2); err != nil {
			return nil, nil, err
		}

		nodes = append(nodes, Node{
			Offset: off,
			Size:   sz,
			Flags:  nodeFlags,
			Path:   p,
		})
	}

	return blocks, nodes, nil
}

// -------------------- 读取 blocks + 解密 + LZ4/LZ4HC 解压 --------------------

func readBlocksAndBuildStream(br *binReader, header16 []byte, blocks []StorageBlock) ([]byte, error) {
	// 预估总解压后大小
	var total int
	for _, b := range blocks {
		total += int(b.UncompressedSize)
	}
	out := make([]byte, 0, total)

	for _, blk := range blocks {
		ct := CompressionType(blk.Flags) // 你 C# 是 flags & mask；你这里 flags 就是 type（和原逻辑一致）
		switch ct {
		case CompressionNone:
			// 读 uncompressedSize bytes，Decrypt(header16, buffer)，直接 append
			n := int(blk.UncompressedSize)
			buf, err := br.ReadBytes(n)
			if err != nil {
				return nil, err
			}
			Decrypt(header16, buf)
			out = append(out, buf...)

		case CompressionLz4, CompressionLz4HC:
			// 读 compressedSize bytes -> Decrypt -> LZ4 解压成 uncompressedSize
			csz := int(blk.CompressedSize)
			usz := int(blk.UncompressedSize)

			comp, err := br.ReadBytes(csz)
			if err != nil {
				return nil, err
			}
			Decrypt(header16, comp)

			dec := make([]byte, usz)
			// 这里用 lz4.UncompressBlock（适用于 block 格式，和你 C# 的 LZ4.Instance.Decompress 对应）
			n, err := lz4.UncompressBlock(comp, dec)
			if err != nil {
				return nil, fmt.Errorf("lz4 decompress failed: %w", err)
			}
			if n != usz {
				// C# 只是 warning；这里也允许继续，但我返回错误更利于定位
				return nil, fmt.Errorf("lz4 decompressed size mismatch: got=%d expected=%d", n, usz)
			}
			out = append(out, dec...)

		default:
			return nil, fmt.Errorf("unsupported compression type: %d (only None/LZ4/LZ4HC are implemented)", ct)
		}
	}
	return out, nil
}

// -------------------- 抽取文件（对应 ReadFiles） --------------------

// ExtractAllToDir：把 Nodes 指向的文件从 BlocksStream 抽出来写到 dir
func (f *Blb3File) ExtractAllToDir(dir string) error {
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	for _, n := range f.Nodes {
		if n.Size < 0 {
			return fmt.Errorf("invalid node size %d for %s", n.Size, n.Path)
		}
		start := int(n.Offset)
		end := start + int(n.Size)
		if start < 0 || end > len(f.BlocksStream) {
			return fmt.Errorf("node out of range: %s offset=%d size=%d stream=%d",
				n.Path, n.Offset, n.Size, len(f.BlocksStream))
		}

		name := filepath.Base(n.Path)
		outPath := filepath.Join(dir, name)
		if err := os.WriteFile(outPath, f.BlocksStream[start:end], 0o644); err != nil {
			return err
		}
	}
	return nil
}

// ExtractOne：只抽一个（返回内存数据）
func (f *Blb3File) ExtractOne(path string) ([]byte, error) {
	for _, n := range f.Nodes {
		if n.Path == path {
			start := int(n.Offset)
			end := start + int(n.Size)
			if start < 0 || end > len(f.BlocksStream) {
				return nil, errors.New("node out of range")
			}
			b := make([]byte, n.Size)
			copy(b, f.BlocksStream[start:end])
			return b, nil
		}
	}
	return nil, fmt.Errorf("not found: %s", path)
}

func mains() {
	fh, err := os.Open("./20527480.blk")
	if err != nil {
		log.Fatal(err)
	}
	defer fh.Close()

	b, err := ParseBlb3(fh)
	if err != nil {
		log.Fatal(err)
	}

	if err := b.ExtractAllToDir("out_unpack"); err != nil {
		log.Fatal(err)
	}

}
func main() {
	var acv = []byte{0xD0, 0x20, 0x41, 0x4A, 0xA2, 0x7A, 0xCE, 0x66, 0x21, 0x7C, 0x8E, 0x45, 0xF4, 0x87, 0x31, 0xDD, 0xD8, 0x35, 0xC2, 0x09, 0xEA, 0x60, 0x38, 0xD2, 0xB4, 0xBE, 0x10, 0x76, 0x7F, 0xB7, 0x0F, 0xFD, 0xCB, 0x02, 0x0E, 0x5B, 0x2E, 0x9B, 0xB1, 0xE1, 0xF5, 0x5E, 0x40, 0x4D, 0x88, 0x98, 0x6F, 0x37, 0xAB, 0xEE, 0x53, 0x79, 0x70, 0x24, 0x6C, 0x67, 0xE6, 0x3C, 0x49, 0x06, 0x59, 0xBA, 0xCF, 0x08, 0x8A, 0xAC, 0xA0, 0x8B, 0x3D, 0xBF, 0x13, 0x73, 0x43, 0x91, 0x00, 0x2B, 0xA1, 0x22, 0x93, 0x3A, 0xCC, 0x4C, 0x44, 0x14, 0x28, 0xF7, 0xED, 0x36, 0x4F, 0xE4, 0xFC, 0x90, 0x0A, 0x9E, 0xD6, 0x77, 0x05, 0xBD, 0x57, 0x3F, 0x96, 0x5F, 0x4B, 0xBC, 0x8D, 0x3E, 0x72, 0xFE, 0x4E, 0xA7, 0xC3, 0xA9, 0x3B, 0x07, 0x89, 0x2F, 0xB8, 0xFF, 0x1D, 0xB6, 0x65, 0x6D, 0xC4, 0x61, 0x39, 0x6A, 0xA3, 0x64, 0xC1, 0xAE, 0xB2, 0x97, 0x29, 0x9F, 0xF2, 0x32, 0x34, 0x1A, 0x58, 0x27, 0x51, 0x71, 0x15, 0x03, 0xEC, 0x47, 0x1E, 0x5C, 0xB3, 0x18, 0x7D, 0xE9, 0x48, 0x6E, 0x55, 0x19, 0x2A, 0xDA, 0x25, 0x80, 0x11, 0xF1, 0x95, 0xE5, 0xE2, 0x83, 0xA5, 0x82, 0x1C, 0x5A, 0xCD, 0xD4, 0x74, 0x9D, 0x33, 0xB5, 0xD5, 0xCA, 0x16, 0xE3, 0x23, 0x84, 0x2C, 0xDE, 0x1B, 0x94, 0xE8, 0x52, 0x01, 0x12, 0x7B, 0x63, 0x50, 0x9A, 0x68, 0xF6, 0xD7, 0x8C, 0x62, 0xE0, 0x17, 0xDB, 0x8F, 0x0C, 0xC0, 0x0D, 0x46, 0xDF, 0xF8, 0x04, 0xEB, 0x75, 0xA6, 0xD1, 0xA4, 0xFB, 0x5D, 0xC8, 0x1F, 0xF3, 0xDC, 0xB0, 0x78, 0xAA, 0x2D, 0xC9, 0x56, 0x9C, 0x86, 0xF9, 0xC6, 0xE7, 0x81, 0x92, 0xA8, 0xEF, 0x54, 0x6B, 0x7E, 0x99, 0xC5, 0xD9, 0xC7, 0xFA, 0xD3, 0x26, 0x30, 0xB9, 0xF0, 0x0B, 0x42, 0xAD, 0x85, 0x69, 0xBB, 0xAF, 0x0B, 0xE2, 0xC2, 0x29, 0xFF, 0xDD, 0xE6, 0x2A, 0xD9, 0x97, 0x30, 0x5E, 0x73, 0x95, 0x48, 0x05, 0x56, 0x26, 0x0F, 0xD2, 0xA2, 0x9A, 0x3C, 0xAE, 0x14, 0xBD, 0xF9, 0x92, 0x23, 0x61, 0x74, 0x31, 0xE1, 0xC3, 0x7A, 0xE5, 0xF0, 0x8A, 0x32, 0xAA, 0x91, 0x1B, 0x79, 0xE7, 0x54, 0x0C, 0x81, 0xD0, 0xD5, 0x08, 0x0E, 0x98, 0x9F, 0x6C, 0xBF, 0xAC, 0x59, 0xED, 0x18, 0x87, 0xDC, 0x85, 0x69, 0xF6, 0x82, 0x01, 0xA7, 0x83, 0x20, 0xD7, 0x10, 0xB9, 0x21, 0x1E, 0x42, 0xD8, 0xB1, 0x4A, 0xA1, 0x66, 0x9D, 0x0D, 0x71, 0x5B, 0x1A, 0xB7, 0x2D, 0xA4, 0x07, 0x65, 0x33, 0x06, 0xF5, 0x67, 0xCF, 0xA8, 0x12, 0xDE, 0x5F, 0x3F, 0x35, 0x13, 0x6F, 0x02, 0x6B, 0xD1, 0xA6, 0x1D, 0xC7, 0x5A, 0x40, 0xB3, 0xF8, 0x90, 0xA5, 0x9B, 0x94, 0xA0, 0x00, 0x60, 0x68, 0x50, 0xDA, 0x43, 0x38, 0x7B, 0x37, 0x4F, 0xF4, 0x58, 0xC5, 0x64, 0x22, 0x3D, 0xC9, 0xFC, 0x0A, 0x3A, 0xBA, 0x78, 0x6A, 0xFA, 0x5C, 0x8C, 0xE0, 0x77, 0x88, 0x41, 0xCD, 0x51, 0x9E, 0xA3, 0x4C, 0x1F, 0xCA, 0x16, 0x6E, 0x28, 0xF1, 0xFE, 0x8E, 0x99, 0xC8, 0xFB, 0x19, 0x7E, 0x7F, 0x45, 0x4D, 0xE4, 0xDF, 0x75, 0x57, 0x6D, 0x2F, 0xBB, 0x46, 0xE3, 0xEA, 0xDB, 0x53, 0x34, 0x36, 0x80, 0xEF, 0xF7, 0x7C, 0x1C, 0xB0, 0x9C, 0x47, 0x62, 0xB2, 0xB5, 0x89, 0x17, 0x09, 0xCE, 0xC6, 0xC1, 0x44, 0xCB, 0x63, 0x8B, 0xD6, 0x84, 0xB4, 0xEE, 0xF3, 0x55, 0x8F, 0xD4, 0x49, 0x3E, 0x2B, 0x96, 0xE8, 0xFD, 0x04, 0x8D, 0x52, 0xBC, 0x93, 0x70, 0xAB, 0xE9, 0x4E, 0xEB, 0x2E, 0x76, 0xA9, 0x86, 0xCC, 0xD3, 0xC4, 0xAF, 0x39, 0x2C, 0xF2, 0x4B, 0xAD, 0x72, 0x5D, 0xBE, 0xEC, 0x27, 0xC0, 0x15, 0x03, 0x24, 0xB6, 0x7D, 0x3B, 0x11, 0xB8, 0x25, 0xDD, 0x2F, 0xFB, 0x06, 0xB1, 0x5B, 0xF2, 0xA5, 0x8C, 0xC9, 0xCA, 0xC7, 0x15, 0xB3, 0xFC, 0x7C, 0xEB, 0xDC, 0x50, 0x91, 0x83, 0x80, 0x82, 0x53, 0xD3, 0xE4, 0xD9, 0x73, 0x64, 0x27, 0xC2, 0xA0, 0x67, 0xEE, 0x54, 0x0D, 0xAA, 0x77, 0x97, 0x85, 0xC5, 0x75, 0x23, 0xA7, 0x37, 0x01, 0x19, 0xD1, 0x79, 0xF8, 0x51, 0xA9, 0x49, 0x3A, 0xE9, 0xF7, 0xF0, 0x5C, 0xD4, 0x74, 0x1A, 0xB9, 0x1D, 0x94, 0x28, 0x13, 0xF4, 0x0A, 0x90, 0x6C, 0xFA, 0x95, 0x70, 0x3B, 0x9F, 0xE3, 0xE2, 0x4E, 0x04, 0xBC, 0xA3, 0x21, 0xD2, 0x5E, 0xDB, 0x30, 0x44, 0x2C, 0x76, 0xE1, 0x3C, 0x69, 0x1C, 0xC0, 0x4F, 0x4B, 0x0B, 0x9A, 0xFD, 0x6F, 0xD8, 0x66, 0xB7, 0x7E, 0x17, 0x25, 0xC3, 0xC8, 0xF3, 0xDE, 0x96, 0x3E, 0x62, 0xFF, 0xDF, 0x4C, 0x2D, 0x10, 0xE8, 0x46, 0xF6, 0xCD, 0x24, 0xE6, 0xC1, 0x61, 0x8F, 0x4A, 0x8B, 0x5F, 0x7A, 0xEA, 0x65, 0x86, 0x31, 0x20, 0xD5, 0x71, 0xF1, 0x48, 0xBE, 0x40, 0x0E, 0x39, 0x43, 0x07, 0x9B, 0x68, 0xCC, 0x3F, 0x60, 0x2A, 0xBD, 0x36, 0xB5, 0x56, 0x42, 0xCE, 0x72, 0x41, 0x45, 0x7F, 0x7B, 0x9E, 0x03, 0x09, 0x98, 0x9D, 0x00, 0xD6, 0x99, 0x1B, 0xB0, 0x5D, 0x6D, 0x63, 0xC6, 0xC4, 0x1E, 0x84, 0xB6, 0x0F, 0x11, 0xAC, 0xE5, 0xAF, 0xB8, 0xBF, 0x3D, 0xAE, 0x55, 0xA4, 0xB4, 0x18, 0x32, 0x1F, 0xF9, 0x93, 0x81, 0x2E, 0xEF, 0x05, 0x22, 0x14, 0x26, 0x87, 0xED, 0xFE, 0x8D, 0xEC, 0xB2, 0xCF, 0x35, 0xCB, 0xE7, 0x6E, 0x5A, 0x7D, 0x29, 0x08, 0x12, 0x52, 0xA1, 0x59, 0x58, 0x9C, 0xD0, 0x2B, 0xA2, 0xBB, 0x4D, 0xA6, 0x88, 0xAB, 0x6A, 0x33, 0xA8, 0x8A, 0x02, 0xAD, 0x8E, 0x16, 0x89, 0xD7, 0x34, 0xE0, 0xBA, 0xF5, 0x38, 0xDA, 0x92, 0x78, 0x6B, 0x47, 0x57, 0x0C, 0x75, 0xBD, 0x5C, 0xFB, 0xC1, 0xAB, 0x47, 0x48, 0x72, 0x0F, 0x46, 0x10, 0x3C, 0xEA, 0xCD, 0x2E, 0xC0, 0x92, 0x02, 0x1D, 0x6F, 0xA0, 0xCC, 0xAC, 0x50, 0x52, 0xD5, 0x0B, 0xDD, 0x06, 0x21, 0xD0, 0x3B, 0xBB, 0xC3, 0xB5, 0xE5, 0x89, 0xB8, 0x1B, 0x1A, 0xDC, 0x3F, 0x6E, 0xDE, 0x9F, 0x39, 0x68, 0xB2, 0x7C, 0x24, 0xA8, 0x64, 0xFE, 0x4F, 0xCE, 0xCF, 0xF1, 0x5D, 0x28, 0xF6, 0xF3, 0xFD, 0x29, 0xB6, 0xA7, 0x8C, 0xA5, 0x49, 0xEB, 0x9C, 0xEE, 0x1C, 0xC4, 0xBA, 0xD7, 0x6A, 0x65, 0x43, 0x6D, 0xC6, 0x8F, 0x7A, 0xD8, 0x7F, 0x96, 0x63, 0x36, 0xF2, 0xDF, 0x62, 0xB0, 0xAA, 0xE1, 0x69, 0x7B, 0x6C, 0x45, 0x3D, 0xB4, 0x51, 0x22, 0x7D, 0x58, 0xD9, 0x60, 0x56, 0xC2, 0x5F, 0x41, 0x01, 0xFF, 0x54, 0x07, 0xA6, 0xED, 0x20, 0x34, 0x26, 0xC8, 0x94, 0x13, 0x4C, 0xD4, 0x12, 0x25, 0x9E, 0x80, 0xB7, 0x66, 0x31, 0x30, 0x0C, 0x40, 0x08, 0xC9, 0xE6, 0xF4, 0x8E, 0xC5, 0x82, 0x71, 0x76, 0x7E, 0x55, 0xEF, 0xE9, 0xEC, 0x19, 0x98, 0x09, 0xD6, 0xB1, 0xDA, 0x5E, 0xBC, 0xD2, 0x03, 0x74, 0x86, 0x0A, 0x5B, 0x17, 0x53, 0x79, 0x2C, 0xDB, 0x0E, 0x78, 0x04, 0x5A, 0xF9, 0x9D, 0x85, 0x8B, 0x83, 0xD1, 0x4D, 0xA2, 0x27, 0xB3, 0x14, 0x84, 0xAD, 0x61, 0xAE, 0x15, 0x90, 0x95, 0x1E, 0xAF, 0x6B, 0x23, 0xE4, 0x16, 0x91, 0x2F, 0x99, 0xFA, 0x00, 0x1F, 0x33, 0xCA, 0xE2, 0x97, 0x2A, 0x67, 0xA9, 0x0D, 0xE7, 0x2B, 0x4A, 0x44, 0x87, 0x2D, 0x42, 0x9B, 0x32, 0x8A, 0x3E, 0xF5, 0xD3, 0x8D, 0x93, 0x18, 0x81, 0x37, 0x88, 0xFC, 0x70, 0xF7, 0xC7, 0xA1, 0x38, 0xCB, 0x4E, 0xA4, 0xA3, 0x57, 0x11, 0xB9, 0x35, 0x73, 0xE8, 0xE0, 0xE3, 0x59, 0x3A, 0x77, 0xBE, 0xF0, 0x05, 0x4B, 0xBF, 0x9A, 0xF8}
	fmt.Println(hex.EncodeToString(acv))
	Scramble(acv)
	fmt.Println(hex.EncodeToString(acv))
	Descramble(acv)
	fmt.Println(hex.EncodeToString(acv))

}
